"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasSubatoms = exports.isQtAtom = exports.traverseAtoms = exports.recurseFlattenAtoms = exports.parseAtoms = exports.SizeKind = exports.MAX_FTYP_ATOM_SIZE = exports.ATOM_PREAMBLE_SIZE = exports.CO64_ATOM = exports.STCO_ATOM = exports.STBL_ATOM = exports.MINF_ATOM = exports.MDIA_ATOM = exports.TRAK_ATOM = exports.CMOV_ATOM = exports.UUID_ATOM = exports.FTYP_ATOM = exports.PICT_ATOM = exports.WIDE_ATOM = exports.SKIP_ATOM = exports.PNOT_ATOM = exports.MOOV_ATOM = exports.MDAT_ATOM = exports.JUNK_ATOM = exports.FREE_ATOM = void 0;
/* eslint-disable no-bitwise */
const util_1 = require("./util");
exports.FREE_ATOM = (0, util_1.asciiToU32Be)('free');
exports.JUNK_ATOM = (0, util_1.asciiToU32Be)('junk');
exports.MDAT_ATOM = (0, util_1.asciiToU32Be)('mdat');
exports.MOOV_ATOM = (0, util_1.asciiToU32Be)('moov');
exports.PNOT_ATOM = (0, util_1.asciiToU32Be)('pnot');
exports.SKIP_ATOM = (0, util_1.asciiToU32Be)('skip');
exports.WIDE_ATOM = (0, util_1.asciiToU32Be)('wide');
exports.PICT_ATOM = (0, util_1.asciiToU32Be)('PICT');
exports.FTYP_ATOM = (0, util_1.asciiToU32Be)('ftyp');
exports.UUID_ATOM = (0, util_1.asciiToU32Be)('uuid');
exports.CMOV_ATOM = (0, util_1.asciiToU32Be)('cmov');
exports.TRAK_ATOM = (0, util_1.asciiToU32Be)('trak');
exports.MDIA_ATOM = (0, util_1.asciiToU32Be)('mdia');
exports.MINF_ATOM = (0, util_1.asciiToU32Be)('minf');
exports.STBL_ATOM = (0, util_1.asciiToU32Be)('stbl');
exports.STCO_ATOM = (0, util_1.asciiToU32Be)('stco');
exports.CO64_ATOM = (0, util_1.asciiToU32Be)('co64');
exports.ATOM_PREAMBLE_SIZE = BigInt(8);
exports.MAX_FTYP_ATOM_SIZE = BigInt(1048576);
var SizeKind;
(function (SizeKind) {
    SizeKind[SizeKind["U32"] = 0] = "U32";
    SizeKind[SizeKind["U64"] = 1] = "U64";
})(SizeKind = exports.SizeKind || (exports.SizeKind = {}));
function parseAtoms(infile, depth = 0, shallow = false) {
    const atoms = [];
    const cur = {
        pos: BigInt(0),
    };
    const len = BigInt(infile.byteLength);
    while (cur.pos < len) {
        if (len - cur.pos < 8) {
            break;
        }
        let fwd; // forward-seek counter
        let atomSize = BigInt((0, util_1.readU32)(cur, infile));
        const atomType = (0, util_1.readU32)(cur, infile);
        let sizeKind = SizeKind.U32;
        if (atomSize === BigInt(1)) {
            // 64-bit atom size
            atomSize = (0, util_1.readU64)(cur, infile);
            if (atomSize > BigInt(Number.MAX_SAFE_INTEGER)) {
                throw new Error(`"${atomType}" atom size is larger than MAX_SAFE_INTEGER!`);
            }
            fwd = atomSize - exports.ATOM_PREAMBLE_SIZE * BigInt(2);
            sizeKind = SizeKind.U64;
        }
        else {
            fwd = atomSize - exports.ATOM_PREAMBLE_SIZE;
        }
        const endOfAtom = cur.pos + fwd;
        const subatoms = Buffer.from(infile.slice(Number(cur.pos), Number(endOfAtom)));
        const data = hasSubatoms(atomType) && depth < 10 && !shallow
            ? parseAtoms(subatoms, depth + 1)
            : subatoms;
        cur.pos = endOfAtom;
        if (depth === 0 && !isQtAtom(atomType)) {
            throw new Error(`Non-QT top-level atom found: ${(0, util_1.u32BeToAscii)(atomType)}`);
        }
        atoms.push({
            kind: (0, util_1.u32BeToAscii)(atomType),
            size: atomSize,
            sizeKind,
            data,
        });
    }
    return atoms;
}
exports.parseAtoms = parseAtoms;
function recurseFlattenAtoms(atoms, depth = 0) {
    const buffers = [];
    for (const atom of atoms) {
        if (!Buffer.isBuffer(atom.data)) {
            atom.data = recurseFlattenAtoms(atom.data, depth + 1);
        }
        let header;
        const u64Size = Number(exports.ATOM_PREAMBLE_SIZE) + atom.data.byteLength > 2 ** 32 - 1;
        if (u64Size) {
            const u64Preamble = Number(exports.ATOM_PREAMBLE_SIZE) * 2;
            header = Buffer.alloc(u64Preamble);
            header.writeUInt32BE(1, 0);
            header.writeUInt32BE((0, util_1.asciiToU32Be)(atom.kind), 4);
            const newSize = u64Preamble + atom.data.byteLength;
            header.writeUInt32BE((newSize >> 32) & 0xffffffff, 8);
            header.writeUInt32BE(newSize & 0xffffffff, 12);
        }
        else {
            header = Buffer.alloc(Number(exports.ATOM_PREAMBLE_SIZE));
            const newSize = Number(exports.ATOM_PREAMBLE_SIZE) + atom.data.byteLength;
            header.writeUInt32BE(newSize, 0);
            header.writeUInt32BE((0, util_1.asciiToU32Be)(atom.kind), 4);
        }
        const buf = Buffer.concat([header, atom.data]);
        buffers.push(buf);
    }
    return Buffer.concat(buffers);
}
exports.recurseFlattenAtoms = recurseFlattenAtoms;
function traverseAtoms(atoms, callback) {
    for (const atom of atoms) {
        if (!Buffer.isBuffer(atom.data)) {
            traverseAtoms(atom.data, callback);
        }
        callback(atom);
    }
}
exports.traverseAtoms = traverseAtoms;
function isQtAtom(atomType) {
    return [
        exports.FREE_ATOM,
        exports.JUNK_ATOM,
        exports.MDAT_ATOM,
        exports.MOOV_ATOM,
        exports.PNOT_ATOM,
        exports.SKIP_ATOM,
        exports.WIDE_ATOM,
        exports.PICT_ATOM,
        exports.FTYP_ATOM,
        exports.UUID_ATOM,
        exports.CMOV_ATOM,
        exports.TRAK_ATOM,
        exports.MDIA_ATOM,
        exports.MINF_ATOM,
        exports.STBL_ATOM,
        exports.STCO_ATOM,
        exports.CO64_ATOM,
    ].includes(atomType);
}
exports.isQtAtom = isQtAtom;
function hasSubatoms(atomType) {
    return [exports.MOOV_ATOM, exports.TRAK_ATOM, exports.MDIA_ATOM, exports.MINF_ATOM, exports.STBL_ATOM].includes(atomType);
}
exports.hasSubatoms = hasSubatoms;
