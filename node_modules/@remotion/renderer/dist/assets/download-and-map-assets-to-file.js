"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.startDownloadForSrc = exports.downloadAndMapAssetsToFileUrl = exports.getSanitizedFilenameForAssetUrl = exports.markAllAssetsAsDownloaded = exports.waitForAssetToBeDownloaded = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const remotion_1 = require("remotion");
const ensure_output_directory_1 = require("../ensure-output-directory");
const download_file_1 = require("./download-file");
const sanitize_filepath_1 = require("./sanitize-filepath");
const isDownloadingMap = {};
const hasBeenDownloadedMap = {};
const listeners = {};
const waitForAssetToBeDownloaded = (src, to) => {
    var _a;
    if ((_a = hasBeenDownloadedMap[src]) === null || _a === void 0 ? void 0 : _a[to]) {
        return Promise.resolve();
    }
    if (!listeners[src]) {
        listeners[src] = {};
    }
    if (!listeners[src][to]) {
        listeners[src][to] = [];
    }
    return new Promise((resolve) => {
        listeners[src][to].push(() => resolve());
    });
};
exports.waitForAssetToBeDownloaded = waitForAssetToBeDownloaded;
const notifyAssetIsDownloaded = (src, to) => {
    if (!listeners[src]) {
        listeners[src] = {};
    }
    if (!listeners[src][to]) {
        listeners[src][to] = [];
    }
    listeners[src][to].forEach((fn) => fn());
    if (!isDownloadingMap[src]) {
        isDownloadingMap[src] = {};
    }
    isDownloadingMap[src][to] = false;
    if (!hasBeenDownloadedMap[src]) {
        hasBeenDownloadedMap[src] = {};
    }
    hasBeenDownloadedMap[src][to] = true;
};
const validateMimeType = (mimeType, src) => {
    if (!mimeType.includes('/')) {
        const errMessage = [
            'A data URL was passed but did not have the correct format so that Remotion could convert it for the video to be rendered.',
            'The format of the data URL must be `data:[mime-type];[encoding],[data]`.',
            'The `mime-type` parameter must be a valid mime type.',
            'The data that was received is (truncated to 100 characters):',
            src.substr(0, 100),
        ].join(' ');
        throw new TypeError(errMessage);
    }
};
function validateBufferEncoding(potentialEncoding, dataUrl) {
    const asserted = potentialEncoding;
    const validEncodings = [
        'ascii',
        'base64',
        'base64url',
        'binary',
        'hex',
        'latin1',
        'ucs-2',
        'ucs2',
        'utf-8',
        'utf16le',
        'utf8',
    ];
    if (!validEncodings.find((en) => asserted === en)) {
        const errMessage = [
            'A data URL was passed but did not have the correct format so that Remotion could convert it for the video to be rendered.',
            'The format of the data URL must be `data:[mime-type];[encoding],[data]`.',
            'The `encoding` parameter must be one of the following:',
            `${validEncodings.join(' ')}.`,
            'The data that was received is (truncated to 100 characters):',
            dataUrl.substr(0, 100),
        ].join(' ');
        throw new TypeError(errMessage);
    }
}
const downloadAsset = async (src, to, onDownload) => {
    var _a, _b;
    if ((_a = hasBeenDownloadedMap[src]) === null || _a === void 0 ? void 0 : _a[to]) {
        return;
    }
    if ((_b = isDownloadingMap[src]) === null || _b === void 0 ? void 0 : _b[to]) {
        return (0, exports.waitForAssetToBeDownloaded)(src, to);
    }
    if (!isDownloadingMap[src]) {
        isDownloadingMap[src] = {};
    }
    isDownloadingMap[src][to] = true;
    const onProgress = onDownload(src);
    (0, ensure_output_directory_1.ensureOutputDirectory)(to);
    if (src.startsWith('data:')) {
        const [assetDetails, assetData] = src.substring('data:'.length).split(',');
        if (!assetDetails.includes(';')) {
            const errMessage = [
                'A data URL was passed but did not have the correct format so that Remotion could convert it for the video to be rendered.',
                'The format of the data URL must be `data:[mime-type];[encoding],[data]`.',
                'The data that was received is (truncated to 100 characters):',
                src.substring(0, 100),
            ].join(' ');
            throw new TypeError(errMessage);
        }
        const [mimeType, encoding] = assetDetails.split(';');
        validateMimeType(mimeType, src);
        validateBufferEncoding(encoding, src);
        const buff = Buffer.from(assetData, encoding);
        await fs_1.default.promises.writeFile(to, buff);
        notifyAssetIsDownloaded(src, to);
        return;
    }
    await (0, download_file_1.downloadFile)(src, to, ({ progress }) => {
        onProgress === null || onProgress === void 0 ? void 0 : onProgress({
            percent: progress,
        });
    });
    notifyAssetIsDownloaded(src, to);
};
const markAllAssetsAsDownloaded = () => {
    Object.keys(hasBeenDownloadedMap).forEach((key) => {
        delete hasBeenDownloadedMap[key];
    });
    Object.keys(isDownloadingMap).forEach((key) => {
        delete isDownloadingMap[key];
    });
};
exports.markAllAssetsAsDownloaded = markAllAssetsAsDownloaded;
const getSanitizedFilenameForAssetUrl = ({ src, downloadDir, }) => {
    if (remotion_1.Internals.AssetCompression.isAssetCompressed(src)) {
        return src;
    }
    const { pathname, search } = new URL(src);
    const split = pathname.split('.');
    const fileExtension = split.length > 1 && split[split.length - 1]
        ? `.${split[split.length - 1]}`
        : '';
    const hashedFileName = String((0, remotion_1.random)(`${pathname}${search}`)).replace('0.', '');
    return path_1.default.join(downloadDir, (0, sanitize_filepath_1.sanitizeFilePath)(hashedFileName + fileExtension));
};
exports.getSanitizedFilenameForAssetUrl = getSanitizedFilenameForAssetUrl;
const downloadAndMapAssetsToFileUrl = async ({ asset, downloadDir, onDownload, }) => {
    const newSrc = await (0, exports.startDownloadForSrc)({
        src: asset.src,
        downloadDir,
        onDownload,
    });
    return {
        ...asset,
        src: newSrc,
    };
};
exports.downloadAndMapAssetsToFileUrl = downloadAndMapAssetsToFileUrl;
const startDownloadForSrc = async ({ src, downloadDir, onDownload, }) => {
    const newSrc = (0, exports.getSanitizedFilenameForAssetUrl)({ downloadDir, src });
    if (!remotion_1.Internals.AssetCompression.isAssetCompressed(newSrc)) {
        await downloadAsset(src, newSrc, onDownload);
    }
    return newSrc;
};
exports.startDownloadForSrc = startDownloadForSrc;
