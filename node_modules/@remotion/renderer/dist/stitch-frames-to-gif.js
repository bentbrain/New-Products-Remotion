"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stitchFramesToGif = exports.spawnFfmpeg = void 0;
const execa_1 = __importDefault(require("execa"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const remotion_1 = require("remotion");
const get_codec_name_1 = require("./get-codec-name");
const get_prores_profile_name_1 = require("./get-prores-profile-name");
const parse_ffmpeg_progress_1 = require("./parse-ffmpeg-progress");
const validate_even_dimensions_with_codec_1 = require("./validate-even-dimensions-with-codec");
const validate_ffmpeg_1 = require("./validate-ffmpeg");
const packageJsonPath = path_1.default.join(__dirname, '..', 'package.json');
const packageJson = fs_1.default.existsSync(packageJsonPath)
    ? JSON.parse(fs_1.default.readFileSync(packageJsonPath, 'utf-8'))
    : null;
const spawnFfmpeg = async (options) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    remotion_1.Internals.validateDimension(options.height, 'height', 'passed to `stitchFramesToVideo()`');
    remotion_1.Internals.validateDimension(options.width, 'width', 'passed to `stitchFramesToVideo()`');
    remotion_1.Internals.validateFps(options.fps, 'passed to `stitchFramesToVideo()`');
    const codec = (_a = options.codec) !== null && _a !== void 0 ? _a : remotion_1.Internals.DEFAULT_CODEC;
    (0, validate_even_dimensions_with_codec_1.validateEvenDimensionsWithCodec)({
        width: options.width,
        height: options.height,
        codec,
        scale: 1,
    });
    const crf = (_b = options.crf) !== null && _b !== void 0 ? _b : remotion_1.Internals.getDefaultCrfForCodec(codec);
    const pixelFormat = (_c = options.pixelFormat) !== null && _c !== void 0 ? _c : remotion_1.Internals.DEFAULT_PIXEL_FORMAT;
    await (0, validate_ffmpeg_1.validateFfmpeg)((_d = options.ffmpegExecutable) !== null && _d !== void 0 ? _d : null);
    const encoderName = (0, get_codec_name_1.getCodecName)(codec);
    const proResProfileName = (0, get_prores_profile_name_1.getProResProfileName)(codec, options.proResProfile);
    const supportsCrf = encoderName && codec !== 'prores';
    if (options.verbose) {
        console.log('[verbose] ffmpeg', (_e = options.ffmpegExecutable) !== null && _e !== void 0 ? _e : 'ffmpeg in PATH');
        console.log('[verbose] encoder', encoderName);
        console.log('[verbose] pixelFormat', pixelFormat);
        if (supportsCrf) {
            console.log('[verbose] crf', crf);
        }
        console.log('[verbose] codec', codec);
        console.log('[verbose] proResProfileName', proResProfileName);
    }
    remotion_1.Internals.validateSelectedCrfAndCodecCombination(crf, codec);
    remotion_1.Internals.validateSelectedPixelFormatAndCodecCombination(pixelFormat, codec);
    const expectedFrames = options.assetsInfo.assets.length;
    const updateProgress = (preStitchProgress, muxProgress) => {
        var _a;
        const totalFrameProgress = 0.5 * preStitchProgress * expectedFrames + muxProgress * 0.5;
        (_a = options.onProgress) === null || _a === void 0 ? void 0 : _a.call(options, Math.round(totalFrameProgress));
    };
    const ffmpegArgs = [
        ['-r', String(options.fps)],
        ...(((_f = options.internalOptions) === null || _f === void 0 ? void 0 : _f.preEncodedFileLocation)
            ? [['-i', (_g = options.internalOptions) === null || _g === void 0 ? void 0 : _g.preEncodedFileLocation]]
            : [
                ['-f', 'image2'],
                ['-s', `${options.width}x${options.height}`],
                ['-start_number', String(options.assetsInfo.firstFrameIndex)],
                ['-i', options.assetsInfo.imageSequenceName],
            ]),
        // -c:v is the same as -vcodec as -codec:video
        // and specified the video codec.
        options.loop === null
            ? null
            : ['-loop', typeof options.loop === 'number' ? options.loop : '-1'],
        // Ignore metadata that may come from remote media
        ['-map_metadata', '-1'],
        [
            '-metadata',
            `comment=` +
                [`Made with Remotion`, packageJson ? packageJson.version : null].join(' '),
        ],
        options.force ? '-y' : null,
        options.outputLocation,
    ];
    if (options.verbose) {
        console.log('Generated FFMPEG command:');
        console.log(ffmpegArgs);
    }
    const ffmpegString = ffmpegArgs.flat(2).filter(Boolean);
    const task = (0, execa_1.default)((_h = options.ffmpegExecutable) !== null && _h !== void 0 ? _h : 'ffmpeg', ffmpegString, {
        cwd: options.dir,
    });
    (_j = options.cancelSignal) === null || _j === void 0 ? void 0 : _j.call(options, () => {
        task.kill();
    });
    let ffmpegOutput = '';
    let isFinished = false;
    (_k = task.stderr) === null || _k === void 0 ? void 0 : _k.on('data', (data) => {
        var _a;
        const str = data.toString();
        ffmpegOutput += str;
        if (options.onProgress) {
            const parsed = (0, parse_ffmpeg_progress_1.parseFfmpegProgress)(str);
            // FFMPEG bug: In some cases, FFMPEG does hang after it is finished with it's job
            // Example repo: https://github.com/JonnyBurger/ffmpeg-repro (access can be given upon request)
            if (parsed !== undefined) {
                // If two times in a row the finishing frame is logged, we quit the render
                if (parsed === expectedFrames) {
                    if (isFinished) {
                        (_a = task.stdin) === null || _a === void 0 ? void 0 : _a.write('q');
                    }
                    else {
                        isFinished = true;
                    }
                }
                updateProgress(1, parsed);
            }
        }
    });
    return { task, getLogs: () => ffmpegOutput };
};
exports.spawnFfmpeg = spawnFfmpeg;
const stitchFramesToGif = async (options) => {
    const { task, getLogs } = await (0, exports.spawnFfmpeg)(options);
    try {
        await task;
    }
    catch (err) {
        throw new Error(getLogs());
    }
};
exports.stitchFramesToGif = stitchFramesToGif;
