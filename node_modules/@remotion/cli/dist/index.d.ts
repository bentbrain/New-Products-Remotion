/// <reference types="minimist" />
import chalk from 'chalk';
export declare const cli: () => Promise<void>;
export * from './render';
export declare const CliInternals: {
    createOverwriteableCliOutput: (quiet: boolean) => {
        update: (up: string) => boolean;
    };
    chalk: chalk.Chalk & chalk.ChalkFunction & {
        supportsColor: false | chalk.ColorSupport;
        Level: chalk.Level;
        Color: ("black" | "blue" | "cyan" | "gray" | "green" | "grey" | "magenta" | "red" | "white" | "yellow" | "blackBright" | "redBright" | "greenBright" | "yellowBright" | "blueBright" | "magentaBright" | "cyanBright" | "whiteBright") | ("bgBlack" | "bgRed" | "bgGreen" | "bgYellow" | "bgBlue" | "bgMagenta" | "bgCyan" | "bgWhite" | "bgGray" | "bgGrey" | "bgBlackBright" | "bgRedBright" | "bgGreenBright" | "bgYellowBright" | "bgBlueBright" | "bgMagentaBright" | "bgCyanBright" | "bgWhiteBright");
        ForegroundColor: "black" | "blue" | "cyan" | "gray" | "green" | "grey" | "magenta" | "red" | "white" | "yellow" | "blackBright" | "redBright" | "greenBright" | "yellowBright" | "blueBright" | "magentaBright" | "cyanBright" | "whiteBright";
        BackgroundColor: "bgBlack" | "bgRed" | "bgGreen" | "bgYellow" | "bgBlue" | "bgMagenta" | "bgCyan" | "bgWhite" | "bgGray" | "bgGrey" | "bgBlackBright" | "bgRedBright" | "bgGreenBright" | "bgYellowBright" | "bgBlueBright" | "bgMagentaBright" | "bgCyanBright" | "bgWhiteBright";
        Modifiers: "bold" | "reset" | "hidden" | "visible" | "italic" | "underline" | "dim" | "inverse" | "strikethrough";
        stderr: chalk.Chalk & {
            supportsColor: false | chalk.ColorSupport;
        };
    };
    makeProgressBar: (percentage: number) => string;
    Log: {
        verbose: (message?: any, ...optionalParams: any[]) => void;
        info: (message?: any, ...optionalParams: any[]) => void;
        warn: (message?: any, ...optionalParams: any[]) => void;
        error: (message?: any, ...optionalParams: any[]) => void;
    };
    loadConfigFile: (configFileName: string, isJavascript: boolean) => Promise<string | null>;
    getCliOptions: (options: {
        isLambda: boolean;
        type: "still" | "series" | "get-compositions";
    }) => Promise<{
        puppeteerTimeout: number;
        parallelism: number | null;
        frameRange: import("remotion").FrameRange | null;
        shouldOutputImageSequence: boolean;
        codec: "h264" | "h265" | "vp8" | "vp9" | "mp3" | "aac" | "wav" | "prores" | "h264-mkv";
        overwrite: boolean;
        inputProps: object;
        envVariables: Record<string, string>;
        quality: number | undefined;
        absoluteOutputFile: string | null;
        browser: import("remotion").Browser;
        crf: number | null;
        pixelFormat: "yuv420p" | "yuva420p" | "yuv422p" | "yuv444p" | "yuv420p10le" | "yuv422p10le" | "yuv444p10le" | "yuva444p10le";
        imageFormat: "png" | "jpeg" | "none";
        proResProfile: "4444-xq" | "4444" | "hq" | "standard" | "light" | "proxy" | undefined;
        stillFrame: number;
        browserExecutable: import("remotion").BrowserExecutable;
        ffmpegExecutable: import("remotion").FfmpegExecutable;
        ffprobeExecutable: import("remotion").FfmpegExecutable;
        logLevel: "verbose" | "info" | "warn" | "error";
        scale: number;
        chromiumOptions: import("@remotion/renderer").ChromiumOptions;
        port: number | null;
    }>;
    parseCommandLine: (type: "sequence" | "still" | "lambda" | "preview" | "versions") => void;
    loadConfig: () => Promise<string | null>;
    initializeRenderCli: (type: "sequence" | "still" | "lambda" | "preview") => Promise<void>;
    BooleanFlags: string[];
    quietFlagProvided: () => boolean;
    parsedCli: import("./parse-command-line").CommandLineOptions & import("minimist").ParsedArgs;
    handleCommonError: (err: Error) => Promise<void>;
};
